//program that calculates polarization transfer assymmetries, with kinematics generated from experimental sample (generated by Tim Kolar)
//meant for calculations for Ca paper

#include <iostream>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <filesystem>


using namespace std;

#include <MeanFieldNucleusThick.hpp>
#include <FsiCorrelator.hpp>
#include <FastParticle.hpp>
#include <constants.hpp>
#include <GlauberGrid.hpp>
#include <OneGlauberGrid.hpp>
#include <GlauberGridThick.hpp>
#include <TKinematics2to2.h>
#include <TElectronKinematics.h>
#include <Cross.hpp>
#include <Utilfunctions.hpp>
#include <NucleonEMOperator.hpp>

//run ./observables [Q2 [MeV^2]] [omega] [missing momentum]
int main(int argc, char *argv[])
{

    string arg_names[5]={"exec name", 
                                "nucleus", 
                                "nucleus shell",
                                "medium modifications ([0] no, [1] CQM, [2] QSM):",
                                "filename that has exp kinematics sample"};

    std::cout << "Compiled from file: " << __FILE__ << std::endl;
    Bookkeep(argc,argv,arg_names);  

    //double Ein=600.2;
    string nucleus_name=argv[1];//atoi(argv[6]);
    int shell=atoi(argv[2]);
    int mmod = atoi(argv[3]);

    std::string exp_sample_file = argv[4];

    

    bool screening=0;//atoi(argv[4]);
    double scr=1.;//atof(argv[5]);
    //string nucleus_name="Ca40";//atoi(argv[6]);
    double prec=1.E-05;//atof(argv[7]);
    int integrator=2;//atoi(argv[8]);
    int thick=1;//atoi(argv[9]);
    int maxEval=20000;//atoi(argv[10]);
    
    string homedir=HOMEDIR;
    MeanFieldNucleusThick nucleus(MeanFieldNucleus::TypeNames.at(nucleus_name),homedir);
    
    cout << "L of shell: " << nucleus.getL_array()[shell] << endl;

    //reading in file for kinematics
    std::ifstream inputFile(exp_sample_file);
    if (!inputFile) {
        std::cout << "Failed to open input file." << std::endl;
        return 1;
    }

    // number of columns in data file 17 right now
    const int numColumns = 17;
    std::vector<std::vector<double>> columns(numColumns);

    std::string line;
    int linesToSkip = 3; // Skip the first 3 lines
    while (linesToSkip > 0 && std::getline(inputFile, line)) {
        linesToSkip--;
    }

    while (std::getline(inputFile, line)) {
        std::istringstream iss(line);
        double value;
        for (int i = 0; i < numColumns; ++i) {
            if (iss >> value) {
                columns[i].push_back(value);
            } else {
                std::cout << "Invalid input format." << std::endl;
                return 1;
            }
        }
    }
    inputFile.close();

    std::filesystem::path directoryPath = std::filesystem::path(exp_sample_file).parent_path();

    // Specify the new filename
    std::string newFilename = "model_output_full"+to_string(argv[1])+"_"+to_string(shell)+".dat";

    // Create the new file path by combining the directory path and new filename
    std::string outputfilepath = (directoryPath / newFilename).string();


    // Open the new file for writing
    std::ofstream outputFile(outputfilepath);
    if (!outputFile) {
        std::cout << "Failed to open output file." << std::endl;
        return 1;
    }
    outputFile << "#Ebeam [MeV], Pmiss [MeV, no sign], Emiss [MeV], Q2 [GeV^2] out|in, thetaq [*] out|in, p_out [MeV] out|in,"
    << " theta_p [*] out|in, phi [*], thetapmq [*], thetapm_beam [*] in, Px [PWIA], Pz [PWIA], Px/Pz [PWIA], Px [RMSGA], "
    << "Pz [RMSGA], Px/Pz [RMSGA], Px/Pz [free]" << endl;


    for (size_t i = 0; i < columns[0].size(); ++i) {
        double Eout = columns[14][i]*1.E03;
        double thetae = columns[15][i]*DEGRTORAD;
        double Ein = columns[0][i]*1.E03;
        double pm = abs(columns[1][i])*1.E03;

        double Emiss_sample = columns[2][i]*1.E03; //[MeV]
        double Q2_sample = -columns[4][i]; // [GeV]
        double thetaq_sample = columns[5][i]; // degrees
        double pvec_sample = columns[8][i]*1.E03; // [MeV]
        double thetapq_sample = columns[10][i]; // degrees
        double phi = columns[11][i]*DEGRTORAD; // radians

        double theta_pm_beam = columns[12][i]; // degrees

        double omega=Ein-Eout;
        double qvec=sqrt(Ein*Ein+Eout*Eout-2.*Ein*Eout*cos(thetae));
        double Q2=qvec*qvec-omega*omega;
        double thetaq=atan2(sin(thetae)*Eout,Ein-Eout*cos(thetae));

        //   cout << "thetaq: " << thetaq*RADTODEGR << endl; 
        //   cout << "Q2: " << Q2*1.E-06 << endl;

        //double Emiss_model = nucleus.getMassA_min_proton()+nucleus.getExcitation()[shell]+MASSP-nucleus.getMassA();

        TElectronKinematics *elec = TElectronKinematics::CreateWithBeamEnergy(Ein);
        Cross obs(*elec,&nucleus,prec,integrator,homedir,screening,scr);
        //mass Amin1 is tweaked to correspond to exp sample Emiss
        TKinematics2to2 kin("","",nucleus.getMassA(),Emiss_sample-MASSP+nucleus.getMassA(),
	    	MASSP,"qsquared:wlab:pklab",Q2,omega,pm);

        // cout << "q|omega|nucl_p|nucl_thetaq|pm|pm_thetaq|";
        // cout << "Px/Pz PWIA" << " " << "Px/Pz RMSGA" << " " << "Px/Pz free" << endl;
        // //cout << "xs_fsisrc|xs_pw|Tratio|rhod|rhopw" << endl;
  


        //this follows the columns in Tim Kolar's files (more or less)
        if(kin.IsPhysical()){
            outputFile << Ein << " " << pm << " " << Emiss_sample << " " << //Emiss_model << " " << 
            Q2_sample << " " << Q2*1.E-06 << " " << thetaq_sample << " " << thetaq*RADTODEGR << " " << 
            kin.GetPYlab() << " " << pvec_sample << " " << acos(kin.GetCosthYlab())*RADTODEGR << " " << thetapq_sample << " " << phi*RADTODEGR << " "
            << acos(kin.GetCosthklab())*RADTODEGR << " " << theta_pm_beam << " ";
        }


        numint::vector_d cross=numint::vector_d(5,0.);
        obs.getAllDiffCross(cross,kin,2,shell,1,phi,20000,1,0, 1.,1.);

        numint::vector_d asymm=numint::vector_d(40,0.);
        obs.getAllObs_xyz(asymm, kin, 2, shell, 1, mmod, phi, 20000, 1,1.,1.);
        NucleonEMOperator nuclFF(Q2,1,0);
        double free_ratio = -2.*MASSP/(Ein+Eout)/tan(thetae/2.)*nuclFF.getGE()/nuclFF.getGM();
        
        outputFile << asymm[37] << " " << asymm[39] << " " <<  asymm[37]/asymm[39] << " " 
        << asymm[5] << " " << asymm[7] << " " << asymm[5]/asymm[7] << " " << free_ratio << endl;
        // // obs.getAllObs_tnl(asymm, kin, 2, shell, 1, 0, phi, 20000, 1,1.,1.);
        // // cout << asymm[37]/asymm[39] << " " << asymm[5]/asymm[7] << " " << free_ratio << endl;


        // delete elec;

    }


    // Close the file
    outputFile.close();



  return 0;




}


